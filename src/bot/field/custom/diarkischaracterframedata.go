// Â© 2019-2024 Diarkis Inc. All rights reserved.

// Code generated by Diarkis Puffer module: DO NOT EDIT.
//
// # Auto-generated by Diarkis Version 1.0.0
//
// - Maximum length of a string is 65535 bytes
// - Maximum length of a byte array is 65535 bytes
// - Maximum length of any array is 65535 elements
package custom

import (
	"encoding/binary"
	"errors"
	"fmt"
	util "github.com/Diarkis/diarkis/util"
	"math"
	"strings"
)

// DiarkisCharacterFrameDataVer represents the ver of the protocol's command.
//
//	[NOTE] The value is optional and if ver is not given in the definition JSON, it will be 0.
const DiarkisCharacterFrameDataVer uint8 = 0

// DiarkisCharacterFrameDataCmd represents the command ID of the protocol's command ID.
//
//	[NOTE] The value is optional and if cmd is not given in the definition JSON, it will be 0.
const DiarkisCharacterFrameDataCmd uint16 = 0

// DiarkisCharacterFrameData represents the command protocol data structure.
type DiarkisCharacterFrameData struct {
	// Command version of the protocol
	Ver uint8
	// Command ID of the protocol
	Cmd                   uint16
	AngularVelocity       *DiarkisVector3
	AnimationBlend        float32
	Engine                string
	IsMoving              bool
	Jump                  bool
	LastFrameSkipped      bool
	Position              *DiarkisVector3
	PreviousFrameInterval float32
	Rotation              *DiarkisQuaternion
	Sprint                bool
	TimeStamp             int64
	Velocity              *DiarkisVector3
	Move                  *DiarkisVector2
}

// NewDiarkisCharacterFrameData creates a new instance of DiarkisCharacterFrameData struct.
func NewDiarkisCharacterFrameData() *DiarkisCharacterFrameData {
	return &DiarkisCharacterFrameData{Ver: 0, Cmd: 0, LastFrameSkipped: false, TimeStamp: 0, Jump: false, Rotation: NewDiarkisQuaternion(), AnimationBlend: 0, Sprint: false, Position: NewDiarkisVector3(), Velocity: NewDiarkisVector3(), AngularVelocity: NewDiarkisVector3(), Engine: "", Move: NewDiarkisVector2(), IsMoving: false, PreviousFrameInterval: 0}
}

// Pack encodes DiarkisCharacterFrameData struct to a byte array to be delivered over the command.
func (proto *DiarkisCharacterFrameData) Pack() []byte {
	bytes := make([]byte, 0)

	/* DiarkisVector3 */
	angularVelocitySizeBytes := make([]byte, 2)
	angularVelocityPacked := proto.AngularVelocity.Pack()
	binary.BigEndian.PutUint16(angularVelocitySizeBytes, uint16(len(angularVelocityPacked)))
	bytes = append(bytes, angularVelocitySizeBytes...)
	bytes = append(bytes, angularVelocityPacked...)

	/* float32 */
	animationBlendBytes := make([]byte, 4)
	animationBlendBits := math.Float32bits(proto.AnimationBlend)
	animationBlendBytes[0] = byte(animationBlendBits >> 24)
	animationBlendBytes[1] = byte(animationBlendBits >> 16)
	animationBlendBytes[2] = byte(animationBlendBits >> 8)
	animationBlendBytes[3] = byte(animationBlendBits)
	//animationBlendBytes = util.ReverseBytes(animationBlendBytes)
	bytes = append(bytes, animationBlendBytes...)

	/* string */
	engineSizeBytes := make([]byte, 2)
	binary.BigEndian.PutUint16(engineSizeBytes, uint16(len(proto.Engine)))
	bytes = append(bytes, engineSizeBytes...)
	bytes = append(bytes, []byte(proto.Engine)...)

	/* bool */
	isMovingBytes := make([]byte, 1)
	if proto.IsMoving {
		isMovingBytes[0] = uint8(1) /* true */
	} else {
		isMovingBytes[0] = uint8(2) /* false */
	}
	bytes = append(bytes, isMovingBytes...)

	/* bool */
	jumpBytes := make([]byte, 1)
	if proto.Jump {
		jumpBytes[0] = uint8(1) /* true */
	} else {
		jumpBytes[0] = uint8(2) /* false */
	}
	bytes = append(bytes, jumpBytes...)

	/* bool */
	lastFrameSkippedBytes := make([]byte, 1)
	if proto.LastFrameSkipped {
		lastFrameSkippedBytes[0] = uint8(1) /* true */
	} else {
		lastFrameSkippedBytes[0] = uint8(2) /* false */
	}
	bytes = append(bytes, lastFrameSkippedBytes...)

	/* DiarkisVector3 */
	positionSizeBytes := make([]byte, 2)
	positionPacked := proto.Position.Pack()
	binary.BigEndian.PutUint16(positionSizeBytes, uint16(len(positionPacked)))
	bytes = append(bytes, positionSizeBytes...)
	bytes = append(bytes, positionPacked...)

	/* float32 */
	previousFrameIntervalBytes := make([]byte, 4)
	previousFrameIntervalBits := math.Float32bits(proto.PreviousFrameInterval)
	previousFrameIntervalBytes[0] = byte(previousFrameIntervalBits >> 24)
	previousFrameIntervalBytes[1] = byte(previousFrameIntervalBits >> 16)
	previousFrameIntervalBytes[2] = byte(previousFrameIntervalBits >> 8)
	previousFrameIntervalBytes[3] = byte(previousFrameIntervalBits)
	//	previousFrameIntervalBytes = util.ReverseBytes(previousFrameIntervalBytes)
	bytes = append(bytes, previousFrameIntervalBytes...)

	/* DiarkisQuaternion */
	rotationSizeBytes := make([]byte, 2)
	rotationPacked := proto.Rotation.Pack()
	binary.BigEndian.PutUint16(rotationSizeBytes, uint16(len(rotationPacked)))
	bytes = append(bytes, rotationSizeBytes...)
	bytes = append(bytes, rotationPacked...)

	/* bool */
	sprintBytes := make([]byte, 1)
	if proto.Sprint {
		sprintBytes[0] = uint8(1) /* true */
	} else {
		sprintBytes[0] = uint8(2) /* false */
	}
	bytes = append(bytes, sprintBytes...)

	/* int64 */
	timeStampBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(timeStampBytes, uint64(proto.TimeStamp))
	bytes = append(bytes, timeStampBytes...)

	/* DiarkisVector3 */
	velocitySizeBytes := make([]byte, 2)
	velocityPacked := proto.Velocity.Pack()
	binary.BigEndian.PutUint16(velocitySizeBytes, uint16(len(velocityPacked)))
	bytes = append(bytes, velocitySizeBytes...)
	bytes = append(bytes, velocityPacked...)

	/* DiarkisVector2 */
	moveSizeBytes := make([]byte, 2)
	movePacked := proto.Move.Pack()
	binary.BigEndian.PutUint16(moveSizeBytes, uint16(len(movePacked)))
	bytes = append(bytes, moveSizeBytes...)
	bytes = append(bytes, movePacked...)

	// done
	return bytes
}

// Unpack decodes the command payload byte array to DiarkisCharacterFrameData struct.
func (proto *DiarkisCharacterFrameData) Unpack(bytes []byte) error {
	if len(bytes) < 32 {
		return errors.New("DiarkisCharacterFrameDataUnpackError")
	}

	offset := 0

	/* DiarkisVector3 */
	angularVelocitySize := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	if angularVelocitySize+offset > len(bytes) {
		return errors.New("UnpackError")
	}
	offset += 2
	angularVelocityBytes := bytes[offset : offset+angularVelocitySize]
	proto.AngularVelocity = &DiarkisVector3{Ver: 0, Cmd: 0}
	proto.AngularVelocity.Unpack(angularVelocityBytes)
	offset += angularVelocitySize

	/* float32 */
	animationBlendBytes := util.ReverseBytes(bytes[offset : offset+4])
	animationBlendBits := binary.BigEndian.Uint32(animationBlendBytes)
	offset += 4
	proto.AnimationBlend = math.Float32frombits(animationBlendBits)

	/* string */
	engineSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if engineSize+offset > len(bytes) {
		return errors.New("UnpackError")
	}
	offset += 2
	proto.Engine = string(bytes[offset : offset+engineSize])
	offset += engineSize

	/* bool */
	isMovingByte := bytes[offset]
	if isMovingByte == 0x01 {
		proto.IsMoving = true
	} else {
		proto.IsMoving = false
	}
	offset++

	/* bool */
	jumpByte := bytes[offset]
	if jumpByte == 0x01 {
		proto.Jump = true
	} else {
		proto.Jump = false
	}
	offset++

	/* bool */
	lastFrameSkippedByte := bytes[offset]
	if lastFrameSkippedByte == 0x01 {
		proto.LastFrameSkipped = true
	} else {
		proto.LastFrameSkipped = false
	}
	offset++

	/* DiarkisVector3 */
	positionSize := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	if positionSize+offset > len(bytes) {
		return errors.New("UnpackError")
	}
	offset += 2
	positionBytes := bytes[offset : offset+positionSize]
	proto.Position = &DiarkisVector3{Ver: 0, Cmd: 0}
	proto.Position.Unpack(positionBytes)
	offset += positionSize

	/* float32 */
	previousFrameIntervalBytes := util.ReverseBytes(bytes[offset : offset+4])
	previousFrameIntervalBits := binary.BigEndian.Uint32(previousFrameIntervalBytes)
	offset += 4
	proto.PreviousFrameInterval = math.Float32frombits(previousFrameIntervalBits)

	/* DiarkisQuaternion */
	rotationSize := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	if rotationSize+offset > len(bytes) {
		return errors.New("UnpackError")
	}
	offset += 2
	rotationBytes := bytes[offset : offset+rotationSize]
	proto.Rotation = &DiarkisQuaternion{Ver: 0, Cmd: 0}
	proto.Rotation.Unpack(rotationBytes)
	offset += rotationSize

	/* bool */
	sprintByte := bytes[offset]
	if sprintByte == 0x01 {
		proto.Sprint = true
	} else {
		proto.Sprint = false
	}
	offset++

	/* int64 */
	proto.TimeStamp = int64(binary.BigEndian.Uint64(bytes[offset : offset+8]))
	offset += 8

	/* DiarkisVector3 */
	velocitySize := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	if velocitySize+offset > len(bytes) {
		return errors.New("UnpackError")
	}
	offset += 2
	velocityBytes := bytes[offset : offset+velocitySize]
	proto.Velocity = &DiarkisVector3{Ver: 0, Cmd: 0}
	proto.Velocity.Unpack(velocityBytes)
	offset += velocitySize

	/* DiarkisVector2 */
	moveSize := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	if moveSize+offset > len(bytes) {
		return errors.New("UnpackError")
	}
	offset += 2
	moveBytes := bytes[offset : offset+moveSize]
	proto.Move = &DiarkisVector2{Ver: 0, Cmd: 0}
	proto.Move.Unpack(moveBytes)
	offset += moveSize

	return nil
}

func (proto *DiarkisCharacterFrameData) String() string {
	list := make([]string, 0)
	list = append(list, fmt.Sprint("AngularVelocity = ", proto.AngularVelocity.String()))
	list = append(list, fmt.Sprint("AnimationBlend = ", proto.AnimationBlend))
	list = append(list, fmt.Sprint("Engine = ", proto.Engine))
	list = append(list, fmt.Sprint("IsMoving = ", proto.IsMoving))
	list = append(list, fmt.Sprint("Jump = ", proto.Jump))
	list = append(list, fmt.Sprint("LastFrameSkipped = ", proto.LastFrameSkipped))
	list = append(list, fmt.Sprint("Position = ", proto.Position.String()))
	list = append(list, fmt.Sprint("PreviousFrameInterval = ", proto.PreviousFrameInterval))
	list = append(list, fmt.Sprint("Rotation = ", proto.Rotation.String()))
	list = append(list, fmt.Sprint("Sprint = ", proto.Sprint))
	list = append(list, fmt.Sprint("TimeStamp = ", proto.TimeStamp))
	list = append(list, fmt.Sprint("Velocity = ", proto.Velocity.String()))
	list = append(list, fmt.Sprint("Move = ", proto.Move.String()))
	return strings.Join(list, " | ")
}

func (proto *DiarkisCharacterFrameData) GetVer() uint8 {
	return proto.Ver
}
func (proto *DiarkisCharacterFrameData) GetCmd() uint16 {
	return proto.Cmd
}

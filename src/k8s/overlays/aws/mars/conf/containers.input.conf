<source>
  @type tail
  
  # path /var/log/containers/mars-0_prd0_mars-*.log
  
  # pos_file /var/run/google-fluentd/pos-files/gcp-containers.pos
  
  # Tags at this point are in the format of:
  # reform.var.log.containers.<POD_NAME>_<NAMESPACE_NAME>_<CONTAINER_NAME>-<CONTAINER_ID>.log
  tag reform.*
  read_from_head true
  <parse>
    @type multi_format
    <pattern>
      format json
      time_key time
      time_format %Y-%m-%dT%H:%M:%S.%NZ
    </pattern>
    <pattern>
      format /^(?<time>.+) (?<stream>stdout|stderr) [^ ]* (?<log>.*)$/
      time_format %Y-%m-%dT%H:%M:%S.%N%:z
    </pattern>
  </parse>
</source>

<filter reform.**>
  @type parser
  format /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<log>.*)/
  reserve_data true
  suppress_parse_error_log true
  emit_invalid_record_to_error false
  key_name log
</filter>


# <filter reform.**>
#   # This plugin uses environment variables KUBERNETES_SERVICE_HOST and
#   # KUBERNETES_SERVICE_PORT to talk to the API server. These environment
#   # variables are added by kubelet automatically.
#   @type kubernetes_metadata
#   # Interval in seconds to dump cache stats locally in the Fluentd log.
#   stats_interval 300
#   # TTL in seconds of each cached element.
#   cache_ttl 30
  
#   # Skip fetching unused metadata.
#   skip_container_metadata true
#   skip_master_url true
#   skip_namespace_metadata true
  
# </filter>

<filter reform.**>
  # We have to use record_modifier because only this plugin supports complex
  # logic to modify record the way we need.
  @type record_modifier
  enable_ruby true
  <record>
    # Extract "kubernetes"->"labels" and set them as
    # "logging.googleapis.com/labels". Prefix these labels with
    # "k8s-pod" to distinguish with other labels and avoid
    # label name collision with other types of labels.
    _dummy_ ${if record.is_a?(Hash) && record.has_key?('kubernetes') && record['kubernetes'].has_key?('labels') && record['kubernetes']['labels'].is_a?(Hash); then; record["logging.googleapis.com/labels"] = record['kubernetes']['labels'].map{ |k, v| ["k8s-pod/#{k}", v]}.to_h; end; nil}
  </record>
  # Delete this dummy field and the rest of "kubernetes" and "docker".
  remove_keys _dummy_,kubernetes,docker
</filter>


<match reform.**>
  @type record_reformer
  enable_ruby true
  <record>
    # Extract local_resource_id from tag for 'k8s_container' monitored
    # resource. The format is:
    # 'k8s_container.<namespace_name>.<pod_name>.<container_name>'.
    "logging.googleapis.com/local_resource_id" ${"k8s_container.#{tag_suffix[4].rpartition('.')[0].split('_')[1]}.#{tag_suffix[4].rpartition('.')[0].split('_')[0]}.#{tag_suffix[4].rpartition('.')[0].split('_')[2].rpartition('-')[0]}"}
    # Rename the field 'log' to a more generic field 'message'. This way the
    # fluent-plugin-google-cloud knows to flatten the field as textPayload
    # instead of jsonPayload after extracting 'time', 'severity' and
    # 'stream' from the record.
    message ${record['log']}
    # If 'severity' is not set, assume stderr is ERROR and stdout is INFO.
    severity ${record['severity'] || if record['stream'] == 'stderr' then 'ERROR' else 'INFO' end}
  </record>
  tag ${if record['stream'] == 'stderr' then 'raw.stderr' else 'raw.stdout' end}
  remove_keys stream,log
</match>

# Detect exceptions in the log output and forward them as one log entry.
<match {raw.stderr,raw.stdout}>
  @type detect_exceptions

  remove_tag_prefix raw
  message message
  stream "logging.googleapis.com/local_resource_id"
  multiline_flush_interval 5
  max_bytes 500000
  max_lines 1000
</match>